/**
 * test-optimized-data-service.js
 * Tests para OptimizedDataService (Fase 2)
 */

import { OptimizedDataService } from "./services/OptimizedDataService.js";

/**
 * Suite de tests para OptimizedDataService
 */
export class OptimizedDataServiceTests {
  constructor() {
    this.testsPassed = 0;
    this.testsFailed = 0;
    this.results = [];
  }

  /**
   * Ejecuta un test individual
   */
  async runTest(name, testFn) {
    try {
      console.log(`\nüß™ Test: ${name}`);
      await testFn();
      this.testsPassed++;
      this.results.push({ name, status: "‚úÖ PASS" });
      console.log(`‚úÖ PASS: ${name}`);
    } catch (error) {
      this.testsFailed++;
      this.results.push({ name, status: "‚ùå FAIL", error: error.message });
      console.error(`‚ùå FAIL: ${name}`, error);
    }
  }

  /**
   * Test 1: Inicializaci√≥n
   */
  async testInitialization() {
    const ods = new OptimizedDataService();

    // Verificar estado inicial
    if (ods.isInitialized) {
      throw new Error("No deber√≠a estar inicializado antes de init()");
    }

    // Inicializar
    const success = await ods.init();

    if (!success) {
      throw new Error("Inicializaci√≥n fall√≥");
    }

    if (!ods.isInitialized) {
      throw new Error("Deber√≠a estar inicializado despu√©s de init()");
    }

    if (!ods.currentMonth) {
      throw new Error("currentMonth no est√° definido");
    }

    if (!ods.estadisticasService) {
      throw new Error("estadisticasService no est√° definido");
    }

    if (!ods.cacheManager) {
      throw new Error("cacheManager no est√° definido");
    }

    await ods.close();
    console.log("‚úì Servicio inicializado correctamente");
  }

  /**
   * Test 2: C√°lculo de claves de mes
   */
  async testMonthKeyCalculation() {
    const ods = new OptimizedDataService();

    // Test getCurrentMonthKey
    const currentMonth = ods.getCurrentMonthKey();
    const regex = /^\d{6}$/; // YYYYMM

    if (!regex.test(currentMonth)) {
      throw new Error(
        `getCurrentMonthKey retorn√≥ formato inv√°lido: ${currentMonth}`
      );
    }

    // Test getMonthKeyFromDate
    const testCases = [
      { input: "2025/01/15", expected: "202501" },
      { input: "20250115", expected: "202501" },
      { input: "2024/12/31", expected: "202412" },
    ];

    for (const { input, expected } of testCases) {
      const result = ods.getMonthKeyFromDate(input);
      if (result !== expected) {
        throw new Error(
          `getMonthKeyFromDate(${input}) = ${result}, esperado: ${expected}`
        );
      }
    }

    console.log("‚úì C√°lculo de claves de mes correcto");
  }

  /**
   * Test 3: Generaci√≥n de lista de meses para rango
   */
  async testMonthsForDateRange() {
    const ods = new OptimizedDataService();

    // Test: 0 d√≠as (solo hoy)
    const months0 = ods.getMonthsForDateRange(0);
    if (months0.length !== 1) {
      throw new Error(
        `0 d√≠as deber√≠a retornar 1 mes, retorn√≥: ${months0.length}`
      );
    }

    // Test: 7 d√≠as (puede ser 1 o 2 meses dependiendo de la fecha)
    const months7 = ods.getMonthsForDateRange(7);
    if (months7.length < 1 || months7.length > 2) {
      throw new Error(
        `7 d√≠as deber√≠a retornar 1-2 meses, retorn√≥: ${months7.length}`
      );
    }

    // Test: 60 d√≠as (deber√≠a ser 2-3 meses)
    const months60 = ods.getMonthsForDateRange(60);
    if (months60.length < 2 || months60.length > 3) {
      throw new Error(
        `60 d√≠as deber√≠a retornar 2-3 meses, retorn√≥: ${months60.length}`
      );
    }

    // Verificar que est√°n ordenados
    const sorted = [...months60].sort();
    if (JSON.stringify(months60) !== JSON.stringify(sorted)) {
      throw new Error("Los meses no est√°n ordenados");
    }

    console.log("‚úì Generaci√≥n de meses para rango correcta");
  }

  /**
   * Test 4: C√°lculo de hash
   */
  async testDataHash() {
    const ods = new OptimizedDataService();

    const testData1 = [{ id: 1, name: "Test" }];
    const testData2 = [{ id: 1, name: "Test" }];
    const testData3 = [{ id: 2, name: "Test" }];

    const hash1 = await ods.calculateDataHash(testData1);
    const hash2 = await ods.calculateDataHash(testData2);
    const hash3 = await ods.calculateDataHash(testData3);

    // Mismo contenido deber√≠a dar mismo hash
    if (hash1 !== hash2) {
      throw new Error("Mismo contenido deber√≠a generar mismo hash");
    }

    // Diferente contenido deber√≠a dar diferente hash
    if (hash1 === hash3) {
      throw new Error("Diferente contenido deber√≠a generar diferente hash");
    }

    // Hash deber√≠a ser SHA-256 (64 caracteres hex)
    if (hash1.length !== 64) {
      throw new Error(
        `Hash deber√≠a tener 64 caracteres, tiene: ${hash1.length}`
      );
    }

    console.log("‚úì C√°lculo de hash correcto");
  }

  /**
   * Test 5: Carga de datos de HOY
   */
  async testLoadTodayData() {
    const ods = new OptimizedDataService();
    await ods.init();

    console.log("Cargando datos de hoy...");
    const todayData = await ods.loadTodayData();

    if (!Array.isArray(todayData)) {
      throw new Error("loadTodayData() deber√≠a retornar un array");
    }

    console.log(`‚úì Datos de hoy cargados: ${todayData.length} registros`);

    await ods.close();
  }

  /**
   * Test 6: Carga b√°sica de datos
   */
  async testLoadData() {
    const ods = new OptimizedDataService();
    await ods.init();

    console.log("Cargando datos (modo b√°sico)...");
    const success = await ods.loadData();

    if (!success) {
      throw new Error("loadData() deber√≠a retornar true en √©xito");
    }

    if (!Array.isArray(ods.errors)) {
      throw new Error("ods.errors deber√≠a ser un array");
    }

    console.log(`‚úì Datos cargados: ${ods.errors.length} registros`);

    await ods.close();
  }

  /**
   * Test 7: Filtrado por rango de fechas
   */
  async testFilterByDateRange() {
    const ods = new OptimizedDataService();

    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const lastWeek = new Date(today);
    lastWeek.setDate(lastWeek.getDate() - 8);

    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}/${month}/${day}`;
    };

    const testRecords = [
      { id: 1, date: formatDate(today), error: "A" },
      { id: 2, date: formatDate(yesterday), error: "B" },
      { id: 3, date: formatDate(lastWeek), error: "C" },
    ];

    // Test: Solo hoy (0 d√≠as)
    const filtered0 = ods.filterByDateRange(testRecords, 0);
    if (filtered0.length !== 1) {
      throw new Error(
        `Rango 0 deber√≠a retornar 1 registro, retorn√≥: ${filtered0.length}`
      );
    }

    // Test: √öltimos 3 d√≠as
    const filtered3 = ods.filterByDateRange(testRecords, 3);
    if (filtered3.length !== 2) {
      throw new Error(
        `Rango 3 deber√≠a retornar 2 registros, retorn√≥: ${filtered3.length}`
      );
    }

    // Test: √öltimos 10 d√≠as
    const filtered10 = ods.filterByDateRange(testRecords, 10);
    if (filtered10.length !== 3) {
      throw new Error(
        `Rango 10 deber√≠a retornar 3 registros, retorn√≥: ${filtered10.length}`
      );
    }

    console.log("‚úì Filtrado por rango de fechas correcto");
  }

  /**
   * Test 8: Proxy a m√©todos del servicio original
   */
  async testProxyMethods() {
    const ods = new OptimizedDataService();
    await ods.init();

    // Test getAvailableDateRanges
    const ranges = ods.getAvailableDateRanges();
    if (!Array.isArray(ranges)) {
      throw new Error("getAvailableDateRanges() deber√≠a retornar un array");
    }

    // Test getCurrentDateRange
    const currentRange = ods.getCurrentDateRange();
    if (typeof currentRange !== "number") {
      throw new Error("getCurrentDateRange() deber√≠a retornar un n√∫mero");
    }

    // Test getLastUpdateFormatted
    const lastUpdate = ods.getLastUpdateFormatted();
    if (typeof lastUpdate !== "string") {
      throw new Error("getLastUpdateFormatted() deber√≠a retornar un string");
    }

    console.log("‚úì M√©todos proxy funcionan correctamente");

    await ods.close();
  }

  /**
   * Test 9: Estad√≠sticas del cach√©
   */
  async testCacheStats() {
    const ods = new OptimizedDataService();
    await ods.init();

    const stats = await ods.getCacheStats();

    if (!stats) {
      throw new Error("getCacheStats() deber√≠a retornar un objeto");
    }

    if (!stats.hasOwnProperty("totalSize")) {
      throw new Error("stats deber√≠a tener propiedad totalSize");
    }

    if (!stats.hasOwnProperty("historicalRecords")) {
      throw new Error("stats deber√≠a tener propiedad historicalRecords");
    }

    if (!stats.hasOwnProperty("loadedMonths")) {
      throw new Error("stats deber√≠a tener propiedad loadedMonths");
    }

    if (!Array.isArray(stats.loadedMonths)) {
      throw new Error("loadedMonths deber√≠a ser un array");
    }

    console.log("‚úì Estad√≠sticas del cach√©:", stats);

    await ods.close();
  }

  /**
   * Test 10: Salud del cach√©
   */
  async testCacheHealth() {
    const ods = new OptimizedDataService();
    await ods.init();

    // No deber√≠a lanzar error
    await ods.checkCacheHealth();

    console.log("‚úì Verificaci√≥n de salud del cach√© correcta");

    await ods.close();
  }

  /**
   * Imprime reporte final
   */
  printReport() {
    console.log("\n" + "‚ïê".repeat(60));
    console.log("üìä REPORTE DE TESTS - OPTIMIZED DATA SERVICE");
    console.log("‚ïê".repeat(60));

    console.table(this.results);

    console.log("\nüìà Resumen:");
    console.log(`   ‚úÖ Tests pasados: ${this.testsPassed}`);
    console.log(`   ‚ùå Tests fallidos: ${this.testsFailed}`);
    console.log(`   üìä Total: ${this.testsPassed + this.testsFailed}`);

    const percentage = (
      (this.testsPassed / (this.testsPassed + this.testsFailed)) *
      100
    ).toFixed(1);
    console.log(`   üéØ Tasa de √©xito: ${percentage}%`);

    console.log("\n" + "‚ïê".repeat(60));

    if (this.testsFailed === 0) {
      console.log("üéâ ¬°TODOS LOS TESTS PASARON!");
    } else {
      console.log("‚ö†Ô∏è  Algunos tests fallaron, revisar detalles arriba");
    }

    console.log("‚ïê".repeat(60) + "\n");
  }
}

/**
 * Ejecuta todos los tests
 */
export async function runOptimizedTests() {
  console.log("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  console.log("‚ïë   üß™ EJECUTANDO TESTS - OPTIMIZED DATA SERVICE       ‚ïë");
  console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");

  const suite = new OptimizedDataServiceTests();

  await suite.runTest("1. Inicializaci√≥n", () => suite.testInitialization());
  await suite.runTest("2. C√°lculo de claves de mes", () =>
    suite.testMonthKeyCalculation()
  );
  await suite.runTest("3. Meses para rango de fechas", () =>
    suite.testMonthsForDateRange()
  );
  await suite.runTest("4. C√°lculo de hash", () => suite.testDataHash());
  await suite.runTest("5. Carga de datos de HOY", () =>
    suite.testLoadTodayData()
  );
  await suite.runTest("6. Carga b√°sica de datos", () => suite.testLoadData());
  await suite.runTest("7. Filtrado por rango de fechas", () =>
    suite.testFilterByDateRange()
  );
  await suite.runTest("8. M√©todos proxy", () => suite.testProxyMethods());
  await suite.runTest("9. Estad√≠sticas del cach√©", () =>
    suite.testCacheStats()
  );
  await suite.runTest("10. Salud del cach√©", () => suite.testCacheHealth());

  suite.printReport();

  return {
    passed: suite.testsPassed,
    failed: suite.testsFailed,
    results: suite.results,
  };
}

// Hacer disponible globalmente
if (typeof window !== "undefined") {
  window.runOptimizedTests = runOptimizedTests;
  window.OptimizedDataServiceTests = OptimizedDataServiceTests;

  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üß™ OPTIMIZED DATA SERVICE TEST SUITE CARGADO           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Para ejecutar los tests:                                ‚ïë
‚ïë  > await runOptimizedTests()                              ‚ïë
‚ïë                                                           ‚ïë
‚ïë  Para usar el OptimizedDataService:                       ‚ïë
‚ïë  > import { OptimizedDataService } from                  ‚ïë
‚ïë    './services/OptimizedDataService.js'                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
}
