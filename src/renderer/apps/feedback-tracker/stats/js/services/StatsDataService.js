/**
 * StatsDataService.js
 * Servicio de datos simplificado para la aplicaci√≥n de stats
 * Reutiliza la l√≥gica de estad√≠sticas pero simplificada
 */

export class StatsDataService {
  constructor() {
    this.errors = [];
    this.dataPaths = [];
    this.currentDataPath = null;
    this.lastUpdateTime = null;
    this.isLoading = false;
    this.dpmoData = null;

    console.log("üìä StatsDataService inicializado");
  }

  /**
   * Inicializa el servicio de datos
   */
  async init() {
    try {
      await this.loadConfig();

      // Cargar datos iniciales
      const success = await this.loadData();

      if (success) {
        console.log("‚úÖ StatsDataService inicializado correctamente");
        return true;
      } else {
        console.warn("‚ö†Ô∏è StatsDataService inicializado sin datos");
        this.errors = [];
        return true;
      }
    } catch (error) {
      console.error("‚ùå Error inicializando StatsDataService:", error);
      this.errors = [];
      return false;
    }
  }

  /**
   * Carga la configuraci√≥n de rutas de datos (copiado de EstadisticasDataService que funciona)
   */
  async loadConfig() {
    try {
      console.log("üîß Cargando configuraci√≥n directamente...");

      // CAMBIO: Usar window.api.getConfig() como en EstadisticasDataService
      const config = await window.api.getConfig();

      if (config && config.dataPaths) {
        this.dataPaths = config.dataPaths;
        console.log("üìÅ Rutas de datos:", this.dataPaths);
      } else {
        throw new Error("No se encontraron rutas de datos en la configuraci√≥n");
      }
    } catch (error) {
      console.warn("‚ö†Ô∏è Error cargando configuraci√≥n directamente:", error);

      // Intentar usar el servicio principal como fallback
      if (
        window.inboundScope &&
        window.inboundScope.configService &&
        window.inboundScope.configService.getConfig
      ) {
        try {
          const config = await window.inboundScope.configService.getConfig();
          if (config && config.dataPaths) {
            this.dataPaths = config.dataPaths;
            console.log("üìÅ Rutas de datos desde servicio:", this.dataPaths);
            return;
          }
        } catch (e) {
          console.warn("‚ö†Ô∏è Error usando servicio de configuraci√≥n:", e);
        }
      }

      // Rutas por defecto como √∫ltimo recurso
      this.dataPaths = [
        "\\\\ant\\dept-eu\\VLC1\\Public\\Apps_Tools\\chuecc\\IB_Scope\\Data\\",
        "C:\\Users\\carlo\\Downloads\\0-Proyecto_IB_Scope\\Analisis\\Data\\",
      ];
      console.log("üìÅ Usando rutas por defecto:", this.dataPaths.length);
    }
  }

  /**
   * Carga los datos de errores (copiado de EstadisticasDataService que funciona)
   */
  async loadData() {
    if (this.isLoading) {
      console.log("‚è≥ Ya hay una carga en progreso...");
      return false;
    }

    this.isLoading = true;
    console.log("üì• Iniciando carga de datos para Stats...");

    let errorsLoaded = false;

    try {
      // Esperar a que inboundScope est√© disponible
      console.log("‚è≥ Esperando a que inboundScope est√© disponible...");
      const scopeAvailable = await this.waitForInboundScope();

      // Intentar obtener datos del servicio principal primero (m√°s r√°pido)
      if (
        scopeAvailable &&
        window.inboundScope &&
        window.inboundScope.dataService
      ) {
        const mainDataService = window.inboundScope.dataService;

        try {
          // Asegurar que el servicio principal est√© inicializado
          if (typeof mainDataService.ensureInitialized === "function") {
            await mainDataService.ensureInitialized();
          }

          if (mainDataService.errors && mainDataService.errors.length > 0) {
            console.log("üöÄ Usando datos del servicio principal (cach√©)");
            this.errors = [...mainDataService.errors];
            this.lastUpdateTime = mainDataService.lastUpdateTime || new Date();
            console.log(
              `‚úÖ Datos obtenidos del servicio principal: ${this.errors.length} registros`
            );
            errorsLoaded = true;
          } else {
            // Intentar cargar datos en el servicio principal
            console.log(
              "üì• Intentando cargar datos en el servicio principal..."
            );

            if (typeof mainDataService.loadInitialData === "function") {
              const loaded = await mainDataService.loadInitialData();
              if (
                loaded &&
                mainDataService.errors &&
                mainDataService.errors.length > 0
              ) {
                console.log("üöÄ Datos cargados en el servicio principal");
                this.errors = [...mainDataService.errors];
                this.lastUpdateTime =
                  mainDataService.lastUpdateTime || new Date();
                console.log(
                  `‚úÖ Datos cargados: ${this.errors.length} registros`
                );
                errorsLoaded = true;
              }
            }
          }
        } catch (error) {
          console.warn("‚ö†Ô∏è Error con el servicio principal:", error);
          // Continuar con carga directa
        }
      }

      // Si no hay datos en el servicio principal, cargar directamente
      if (!errorsLoaded) {
        console.log("üìÇ Cargando datos directamente desde archivo...");
        const result = await this.readDataFile();

        if (result && result.success) {
          this.errors = result.data?.errors || result.data || [];
          this.lastUpdateTime = new Date();
          console.log(
            `‚úÖ Datos cargados directamente: ${this.errors.length} registros`
          );
          errorsLoaded = true;
        } else {
          console.error(
            "‚ùå Error cargando datos:",
            result?.error || "Sin datos"
          );
          this.errors = [];
        }
      }

      // IMPORTANTE: Cargar datos DPMO independientemente del resultado de la carga de errores
      console.log("üìä Cargando datos DPMO independientemente del resultado...");
      await this.loadDPMOData();

      return errorsLoaded;
    } catch (error) {
      console.error("‚ùå Error en loadData:", error);
      this.errors = [];
      return false;
    } finally {
      // Siempre intentar cargar DPMO antes de finalizar
      if (this.dpmoData === null) {
        console.log("üìä √öltimo intento de cargar datos DPMO...");
        await this.loadDPMOData();
      }

      this.isLoading = false;
    }
  }

  /**
   * Espera a que inboundScope est√© disponible (m√°ximo 5 segundos)
   */
  async waitForInboundScope(timeout = 5000) {
    return new Promise((resolve) => {
      if (window.inboundScope && window.inboundScope.dataService) {
        resolve(true);
        return;
      }

      let elapsed = 0;
      const interval = 100;

      const checkInterval = setInterval(() => {
        elapsed += interval;

        if (window.inboundScope && window.inboundScope.dataService) {
          clearInterval(checkInterval);
          resolve(true);
        } else if (elapsed >= timeout) {
          clearInterval(checkInterval);
          resolve(false);
        }
      }, interval);
    });
  }

  /**
   * Intenta cargar datos del servicio de feedback-tracker espec√≠ficamente
   */
  tryLoadFromFeedbackTracker() {
    console.log("üîç Buscando datos de feedback-tracker...");

    // Buscar el servicio de feedback-tracker en m√∫ltiples ubicaciones posibles
    const possibleSources = [
      {
        name: "window.feedbackTrackerDataService",
        source: window.feedbackTrackerDataService,
      },
      {
        name: "window.feedbackTracker?.dataService",
        source: window.feedbackTracker?.dataService,
      },
      {
        name: "window.inboundScope?.feedbackTracker?.dataService",
        source: window.inboundScope?.feedbackTracker?.dataService,
      },
      {
        name: "window.inboundScope?.dataServices?.feedbackTracker",
        source: window.inboundScope?.dataServices?.feedbackTracker,
      },
      {
        name: "window.feedbackTrackerData",
        source: window.feedbackTrackerData,
      },
      { name: "window.errorsData", source: window.errorsData },
    ];

    for (const { name, source } of possibleSources) {
      console.log(
        `üîç Verificando ${name}:`,
        source ? "‚úì Existe" : "‚úó No existe"
      );

      if (source) {
        console.log(
          `  - Tiene errors:`,
          source.errors ? `‚úì (${source.errors?.length || 0} registros)` : "‚úó No"
        );

        if (source.errors && source.errors.length > 0) {
          this.errors = [...source.errors];
          this.lastUpdateTime = source.lastUpdateTime || new Date();
          console.log(
            `‚úÖ Datos cargados desde ${name}: ${this.errors.length} registros`
          );

          // Mostrar muestra de datos
          if (this.errors.length > 0) {
            console.log("üìã Muestra de datos encontrados:");
            this.errors.slice(0, 2).forEach((error, index) => {
              console.log(
                `  ${index + 1}. ${
                  error.violation || error.error || "Sin descripci√≥n"
                } - Cantidad: ${error.quantity || 1}`
              );
            });
          }

          return true;
        }
      }
    }

    // Buscar datos directamente en variables globales
    console.log(
      "üîç Verificando window.currentErrorsData:",
      window.currentErrorsData ? "‚úì Existe" : "‚úó No existe"
    );

    if (
      window.currentErrorsData &&
      Array.isArray(window.currentErrorsData) &&
      window.currentErrorsData.length > 0
    ) {
      this.errors = [...window.currentErrorsData];
      this.lastUpdateTime = new Date();
      console.log(
        `‚úÖ Datos cargados desde window.currentErrorsData: ${this.errors.length} registros`
      );
      return true;
    }

    console.log(
      "‚ùå No se encontraron datos de feedback-tracker en ninguna ubicaci√≥n"
    );
    return false;
  }

  /**
   * Intenta cargar datos del servicio principal global
   */
  tryLoadFromGlobalService() {
    console.log("üîç Verificando servicio principal global...");
    console.log(
      "üîç window.inboundScope:",
      window.inboundScope ? "‚úì Existe" : "‚úó No existe"
    );

    if (window.inboundScope) {
      console.log(
        "üîç window.inboundScope.dataService:",
        window.inboundScope.dataService ? "‚úì Existe" : "‚úó No existe"
      );

      if (window.inboundScope.dataService) {
        console.log(
          "üîç dataService.errors:",
          window.inboundScope.dataService.errors
            ? `‚úì (${
                window.inboundScope.dataService.errors?.length || 0
              } registros)`
            : "‚úó No existe"
        );

        if (
          window.inboundScope.dataService.errors &&
          window.inboundScope.dataService.errors.length > 0
        ) {
          this.errors = [...window.inboundScope.dataService.errors];
          this.lastUpdateTime =
            window.inboundScope.dataService.lastUpdateTime || new Date();
          console.log(
            `‚úÖ Datos cargados desde servicio principal: ${this.errors.length} registros`
          );
          return true;
        }
      }
    }

    console.log("‚ùå No se encontraron datos en el servicio principal global");
    return false;
  }

  /**
   * Lee el archivo de datos m√°s reciente (copiado de EstadisticasDataService)
   */
  async readDataFile() {
    // Intentar primero con la ruta actual si est√° disponible (m√°s eficiente)
    if (this.currentDataPath) {
      try {
        console.log(
          `üéØ Intentando leer desde ruta actual: ${this.currentDataPath}`
        );

        // Probar diferentes formatos de archivo
        const today = new Date();
        const dateFormats = [
          this.formatDate(today),
          this.formatDate(new Date(today.getTime() - 24 * 60 * 60 * 1000)), // Ayer
          this.formatDate(new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000)), // Anteayer
        ];

        for (const dateStr of dateFormats) {
          const fileName = `error_tracker_${dateStr}.json`;
          const filePath = `${this.currentDataPath}/${fileName}`;

          try {
            console.log(`üéØ Intentando leer: ${filePath}`);
            const data = await window.api.readJson(filePath);

            if (data && (Array.isArray(data) || data.errors)) {
              console.log(
                `‚úÖ Archivo le√≠do exitosamente desde ruta actual: ${this.currentDataPath}`
              );
              return {
                success: true,
                data: Array.isArray(data) ? { errors: data } : data,
              };
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è No se pudo leer: ${filePath}`);
            continue;
          }
        }
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è Error leyendo desde ruta actual ${this.currentDataPath}:`,
          error
        );
      }
    }

    // Si no hay ruta actual o fall√≥, probar todas las rutas
    console.log("üîÑ Probando todas las rutas disponibles...");

    const today = new Date();
    const dateFormats = [
      this.formatDate(today),
      this.formatDate(new Date(today.getTime() - 24 * 60 * 60 * 1000)), // Ayer
      this.formatDate(new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000)), // Anteayer
    ];

    for (const path of this.dataPaths) {
      for (const dateStr of dateFormats) {
        const fileName = `error_tracker_${dateStr}.json`;
        const fullPath = `${path}/${fileName}`;

        try {
          console.log(`üéØ Intentando leer: ${fullPath}`);
          const data = await window.api.readJson(fullPath);

          if (data && (Array.isArray(data) || data.errors)) {
            this.currentDataPath = path;
            console.log(`‚úÖ Archivo le√≠do exitosamente: ${fullPath}`);
            return {
              success: true,
              data: Array.isArray(data) ? { errors: data } : data,
            };
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è No se pudo leer: ${fullPath}`);
          continue;
        }
      }
    }

    console.log("‚ùå No se encontr√≥ ning√∫n archivo de datos");
    return { success: false, error: "No se encontr√≥ ning√∫n archivo de datos" };
  }

  /**
   * Formatea una fecha para el nombre del archivo
   */
  formatDate(date) {
    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const year = date.getFullYear();
    return `${day}${month}${year}`;
  }

  /**
   * Refresca los datos
   */
  async refresh() {
    console.log("üîÑ Refrescando datos...");

    // Limpiar datos actuales
    this.errors = [];
    this.lastUpdateTime = null;

    // Recargar configuraci√≥n
    await this.loadConfig();

    // Cargar datos frescos
    return await this.loadData();
  }

  /**
   * Recarga completamente los datos (fuerza recarga desde todas las fuentes)
   */
  async reloadData() {
    console.log("üîÑ Forzando recarga completa de datos...");

    // Limpiar datos actuales y cach√©
    this.errors = [];
    this.lastUpdateTime = null;
    this.currentDataPath = null;
    this.isLoading = false; // Resetear estado de carga
    this.dpmoData = null; // Limpiar datos DPMO

    // Recargar configuraci√≥n desde cero
    await this.loadConfig();

    // Intentar cargar datos desde todas las fuentes posibles
    const success = await this.loadData();

    if (success) {
      console.log(
        `‚úÖ Datos recargados exitosamente: ${this.errors.length} registros`
      );
    } else {
      console.warn("‚ö†Ô∏è No se pudieron recargar datos");
    }

    return success;
  }

  /**
   * Carga los datos de DPMO desde el archivo Errors_DPMO_[Fecha].json
   * Usa FileService para mantener consistencia con la carga de otros archivos
   */
  async loadDPMOData() {
    console.log("üìä Cargando datos de DPMO...");

    // Obtener una instancia de FileService
    // Importamos din√°micamente para evitar problemas de dependencias circulares
    let FileService;
    try {
      console.log("üîç Verificando disponibilidad de FileService...");
      console.log(
        "üîç window.inboundScope:",
        window.inboundScope ? "‚úì Existe" : "‚úó No existe"
      );

      if (window.inboundScope) {
        console.log(
          "üîç window.inboundScope.fileService:",
          window.inboundScope.fileService ? "‚úì Existe" : "‚úó No existe"
        );
      }

      if (window.inboundScope && window.inboundScope.fileService) {
        console.log("üìÅ Usando FileService desde inboundScope");
        FileService = window.inboundScope.fileService;
      } else {
        console.log("üìÅ Creando nueva instancia de FileService");
        console.log(
          "üìÅ Intentando importar desde: ../../../js/services/FileService.js"
        );

        try {
          // Importar din√°micamente FileService - corregir ruta
          const module = await import("../../../js/services/FileService.js");
          console.log("üìÅ M√≥dulo FileService importado:", module);
          FileService = new module.FileService();
          console.log("üìÅ Nueva instancia de FileService creada");
        } catch (importError) {
          console.error("‚ùå Error al importar FileService:", importError);
          throw importError;
        }
      }
    } catch (error) {
      console.error("‚ùå Error al obtener FileService:", error);
      console.log("üìÅ Intentando m√©todo fallback directo...");
      // Fallback a window.api.readJson si no podemos obtener FileService
      return this.loadDPMODataFallback();
    }

    // Probar diferentes formatos de archivo para DPMO
    const today = new Date();
    const dateFormats = [
      this.formatDate(today),
      this.formatDate(new Date(today.getTime() - 24 * 60 * 60 * 1000)), // Ayer
      this.formatDate(new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000)), // Anteayer
    ];

    console.log(`üîç Formatos de fecha a probar: ${dateFormats.join(", ")}`);

    // Generar nombres de archivo para cada formato de fecha
    const fileNames = dateFormats.map(
      (dateStr) => `Errors_DPMO_${dateStr}.json`
    );

    // A√±adir nombres alternativos
    const alternativeNames = [
      "Errors_DPMO.json",
      "DPMO.json",
      "dpmo_data.json",
    ];

    // Combinar todos los nombres de archivo a probar
    const allFileNames = [...fileNames, ...alternativeNames];

    console.log(`üìã Nombres de archivo a probar: ${allFileNames.join(", ")}`);

    // Intentar cargar cada nombre de archivo en orden
    for (const fileName of allFileNames) {
      console.log(`üîç Buscando archivo: ${fileName}`);

      try {
        // Usar tryReadJsonFromPaths para buscar en todas las rutas disponibles
        const result = await FileService.tryReadJsonFromPaths(
          this.dataPaths,
          fileName
        );

        if (result && result.success && result.data && result.data.dpmo) {
          console.log(
            `‚úÖ Archivo DPMO encontrado: ${fileName} en ${result.pathUsed}`
          );

          // Actualizar currentDataPath si se encontr√≥ un archivo
          if (result.pathUsed && !this.currentDataPath) {
            this.currentDataPath = result.pathUsed;
            console.log(`‚úÖ Actualizada ruta actual a: ${result.pathUsed}`);
          }

          // Procesar los datos
          this.dpmoData = {
            dpmo: result.data.dpmo,
            totalMovimientos: result.data.total_movimientos || 0,
            totalErrores: result.data.total_errores || 0,
            fecha: result.data.fecha || this.formatDate(new Date()),
            sigma: result.data.sigma || 0,
            calidad: result.data.calidad || "N/A",
            ultimaActualizacion:
              result.data.ultima_actualizacion || new Date().toISOString(),
          };
          return true;
        }
      } catch (error) {
        console.error(`‚ùå Error al buscar ${fileName}:`, error);
        // Continuar con el siguiente nombre de archivo
      }
    }

    console.warn("‚ö†Ô∏è No se encontr√≥ ning√∫n archivo DPMO v√°lido");

    // Si llegamos aqu√≠, no se encontr√≥ ning√∫n archivo DPMO
    return this.loadDPMODataFallback();
  }

  /**
   * M√©todo de respaldo para cargar datos DPMO cuando falla FileService
   */
  async loadDPMODataFallback() {
    console.log("üìä Usando m√©todo fallback para cargar DPMO...");

    // Probar diferentes formatos de archivo para DPMO
    const today = new Date();
    const dateFormats = [
      this.formatDate(today),
      this.formatDate(new Date(today.getTime() - 24 * 60 * 60 * 1000)), // Ayer
      this.formatDate(new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000)), // Anteayer
    ];

    // PASO 1: Intentar con currentDataPath si est√° disponible
    if (this.currentDataPath) {
      console.log(
        `üîç Intentando buscar DPMO en ruta actual: ${this.currentDataPath}`
      );

      for (const dateStr of dateFormats) {
        const fileName = `Errors_DPMO_${dateStr}.json`;
        const filePath = `${this.currentDataPath}/${fileName}`;

        try {
          console.log(`üéØ Intentando leer DPMO: ${filePath}`);
          const data = await window.api.readJson(filePath);

          if (data && data.dpmo) {
            this.dpmoData = {
              dpmo: data.dpmo,
              totalMovimientos: data.total_movimientos,
              totalErrores: data.total_errores,
              fecha: data.fecha,
              sigma: data.sigma,
              calidad: data.calidad,
              ultimaActualizacion: data.ultima_actualizacion,
            };

            return true;
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è No se pudo leer DPMO: ${filePath}`);
          continue;
        }
      }
    }

    // PASO 2: Probar en todas las rutas configuradas
    for (const path of this.dataPaths) {
      for (const dateStr of dateFormats) {
        const fileName = `Errors_DPMO_${dateStr}.json`;
        const fullPath = `${path}/${fileName}`;

        try {
          console.log(`üéØ Intentando leer DPMO: ${fullPath}`);
          const data = await window.api.readJson(fullPath);

          if (data && data.dpmo) {
            this.dpmoData = {
              dpmo: data.dpmo,
              totalMovimientos: data.total_movimientos,
              totalErrores: data.total_errores,
              fecha: data.fecha,
              sigma: data.sigma,
              calidad: data.calidad,
              ultimaActualizacion: data.ultima_actualizacion,
            };

            // Guardar la ruta exitosa como currentDataPath si no estaba definida
            if (!this.currentDataPath) {
              this.currentDataPath = path;
              console.log(`‚úÖ Actualizada ruta actual a: ${path}`);
            }

            return true;
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è No se pudo leer DPMO: ${fullPath}`);
          continue;
        }
      }
    }

    // PASO 3: Probar con nombres de archivo alternativos
    const alternativeNames = [
      "Errors_DPMO.json",
      "DPMO.json",
      "dpmo_data.json",
    ];

    for (const path of this.dataPaths) {
      for (const altName of alternativeNames) {
        const fullPath = `${path}/${altName}`;

        try {
          console.log(`üéØ Intentando leer DPMO alternativo: ${fullPath}`);
          const data = await window.api.readJson(fullPath);

          if (data && data.dpmo) {
            this.dpmoData = {
              dpmo: data.dpmo,
              totalMovimientos: data.total_movimientos || 0,
              totalErrores: data.total_errores || 0,
              fecha: data.fecha || this.formatDate(new Date()),
              sigma: data.sigma || 0,
              calidad: data.calidad || "N/A",
              ultimaActualizacion:
                data.ultima_actualizacion || new Date().toISOString(),
            };

            return true;
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è No se pudo leer DPMO alternativo: ${fullPath}`);
          continue;
        }
      }
    }

    console.warn("‚ö†Ô∏è No se encontraron datos DPMO en ninguna ubicaci√≥n");

    // NO USAR DATOS FALSOS - Es peligroso
    this.dpmoData = null;
    return false;
  }

  /**
   * Obtiene estad√≠sticas b√°sicas de los errores
   */
  getBasicStats(dateRange = 0) {
    const now = new Date();
    let startDate;
    let endDate;

    if (dateRange === 0) {
      // Para "hoy": desde las 00:00:00 hasta las 23:59:59 de hoy
      startDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        0,
        0,
        0
      );
      endDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        23,
        59,
        59
      );
    } else {
      // Para otros rangos: desde hace X d√≠as hasta ahora
      startDate = new Date(now.getTime() - dateRange * 24 * 60 * 60 * 1000);
      endDate = now;
    }

    console.log(
      `üìä Calculando estad√≠sticas para rango: ${
        dateRange === 0 ? "HOY" : dateRange + " d√≠as"
      }`
    );
    console.log(
      `üìÖ Rango de fechas: ${startDate.toISOString().split("T")[0]} - ${
        endDate.toISOString().split("T")[0]
      }`
    );
    console.log(`üìÅ Total de errores disponibles: ${this.errors.length}`);

    // Filtrar errores por rango de fecha
    let filteredErrors = this.errors.filter((error) => {
      const errorDate = new Date(
        error.created_date || error.date || error.timestamp
      );
      const isInRange = errorDate >= startDate && errorDate <= endDate;

      if (!isInRange && dateRange === 0) {
        console.log(
          `‚è∞ Error excluido - Fecha: ${
            errorDate.toISOString().split("T")[0]
          }, Expected: ${startDate.toISOString().split("T")[0]}`
        );
      }

      return isInRange;
    });

    // IMPORTANTE: Si no hay errores para "Hoy", usar todos los errores disponibles
    if (filteredErrors.length === 0 && this.errors.length > 0) {
      console.log(
        "‚ö†Ô∏è No hay errores para el rango seleccionado. Mostrando todos los errores disponibles."
      );
      filteredErrors = [...this.errors];
    }

    console.log(
      `‚úÖ Errores filtrados: ${filteredErrors.length}${
        filteredErrors.length === this.errors.length ? " (mostrando todos)" : ""
      }`
    );

    // Calcular estad√≠sticas
    const totalErrors = filteredErrors.reduce(
      (sum, error) => sum + (error.quantity || 1),
      0
    );
    const totalLines = filteredErrors.length;

    // Determinar errores resueltos usando m√∫ltiples criterios
    const resolvedErrors = filteredErrors.filter((error) => {
      return (
        error.feedback_status === "done" ||
        error.status === "done" ||
        error.status === "resolved" ||
        error.resolved === true ||
        error.is_resolved === true ||
        error.done_date ||
        error.resolved_date
      );
    });

    const resolvedQuantity = resolvedErrors.reduce(
      (sum, error) => sum + (error.quantity || 1),
      0
    );
    const pendingQuantity = totalErrors - resolvedQuantity;

    // Calcular tasa de resoluci√≥n (porcentaje)
    const resolutionRate =
      totalErrors > 0 ? Math.round((resolvedQuantity / totalErrors) * 100) : 0;

    // Calcular promedio diario (para los √∫ltimos 7 d√≠as si hay suficientes datos)
    const daysToAverage = Math.min(7, dateRange || 7);
    const dailyAverage = Math.round(totalErrors / daysToAverage);

    // Incluir datos DPMO si est√°n disponibles
    const stats = {
      totalErrors,
      totalLines,
      resolvedErrors: resolvedQuantity,
      pendingErrors: pendingQuantity,
      resolutionRate,
      dailyAverage,
      dpmo: this.dpmoData,
    };

    console.log(`üìä Estad√≠sticas calculadas: ${JSON.stringify(stats)}`);
    return stats;
  }
}
